\chapter{Cuadricoptero con vision artificial}\label{sec: Cuadricoptero}
En el presente capítulo se pretende abordar el diseño y la implementación de un cuadricóptero con la capacidad para el seguimiento de un objeto, haciendo uso para ello de una FPGA como parte fundamental, y algunas otras herramientas que se expondrán a lo largo de esta sección. \newline

\section{Diseño}
En la figura se presenta un esquema con un alto nivel de abstracción en el que se da una primera aproximación del funcionamiento del sistema general.

\begin{figure}[H]
	\center
	\includegraphics[trim = 0mm 0.5cm 0mm 0.5cm, clip,scale=0.4]{imagenes/Cuadricoptero_vision/on_board.pdf}
	\caption{Diseño a alto nivel del cuadricóptero con visión.}
	\label{fig:on_board}
\end{figure}

Se diferencia en este diseño la parte del control de la estabilización y la parte de percepción. 
En cuánto a la parte de la percepción, una cámara de bajo coste se conectará a la FPGA la cuál deberá implementar todo el algoritmo de reconocimiento del objeto. Previo a ello, y mediante protocolo i2c la cámara sera configurada de modo que facilite ese reconocimiento. Posteriormente y como salida de este algoritmo de reconocimiento la FPGA generará 4 canales PWM correspondientes al yaw, pitch, roll y altitud. Se hace uso de un PPM encoder, el cuál transforma estas 8 señales PWM en un canal PPM, entrada del sistema de estabilización del cuadricóptero "Pixhawk".

\section{Implementación de la percepción}
El módulo OV7670 [] cuenta con un sensor de imagen CMOS VGA OV7670, que permite trabajar a un máximo de 30 cuadros por segundos y una resolución de 640x480 píxeles. Es un sistema en chip (System on Chip, SoC) que es capaz de realizar procesamiento de imágenes, como: control de exposición, gamma, balance de blancos, saturación de color, control de tono. Estos parámetros se pueden configurar  mediante la interface SCCB (Bus de Control de Cámara Serial).

Algunas de las características más importantes se presentan a continuación, y las cuáles pueden ser obtenidas de su datasheet:

\begin{itemize}
	\item Voltaje de operación 3.3 VDC 
	\item Corriente Sleep 20 $\mu$A
	\item Transmisión de datos 8bits en paralelo 
	\item Interface de control estándar SCCB, compatible con I2C 
	\item Lente óptico de 1/6” 
	\item Ángulo de visión (FOV): $25^{\circ}$C
	\item Resolución 640x480 VGA 
	\item Sensibilidad 1.3V / (Lux-sec) 
	\item Ratio Señal-Ruido (SNR): 46 dB 
	\item Alta sensibilidad en ambientes de poca iluminación 
	\item Bajo voltaje, adecuado para aplicaciones portátiles 
\end{itemize}

Una imagen del módulo OV7670 se representa en la \ref{fig:OV7670}.

\begin{figure}[H]
	\center
	\includegraphics[scale=0.4, angle=0]{imagenes/Cuadricoptero_vision/OV7670}
	\caption{Cámara OV7670.}
	\label{fig:OV7670}
\end{figure}

La configuración de la cámara se realiza a través de una interfaz SCCB [], muy parecida a una comunicación I2C y cuyos registros se pueden encontrar en el datasheet. Por tanto, se ha de elegir una configuración adecuada para este propósito:

\begin{itemize}
	\item Se elije un tamaño de ventana de 640x480 debido a los pocos recursos de la tarjeta FPGA utilizada.
	\item El tipo de datos de salida será RGB, por la simplicidad en el uso. Obtendremos por tanto dos bytes por cada píxel capturado en el siguiente orden: 
	
		\begin{figure}[H]
			\center
			\includegraphics[trim = 0mm 0.5cm 0mm 0.5cm, clip,scale=0.6]{imagenes/Cuadricoptero_vision/pixel_OV7670}
			\caption{Formación de píxel en OV7670.}
			\label{fig:pixel_OV7670}
		\end{figure}
	
\end{itemize}

\subsubsection{I2C Protocolo}

Para conseguir esa configuración es necesario una comunicación I2C con el módulo OV7670 que permite escribir en determinados registros.

El aspecto en IceStudio de esta escritura en I2C tiene el aspecto de la figura \ref{fig:I2C_write}.
\begin{figure}[H]
	\center
	\includegraphics[scale=0.4, angle=0]{imagenes/Cuadricoptero_vision/I2C_write.PNG}
	\caption{Aspecto en IceStudio del módulo de escritura I2C.}
	\label{fig:I2C_write}
\end{figure}

Debido a que ha sido un módulo desarrollado íntegramente para esta aplicación, se representa el diagrama de flujo en la figura \ref{fig:i2c_write}

\begin{figure}[H]
	\center
	\includegraphics[trim = 0mm 6cm 0mm 6cm, clip,scale=0.5]{imagenes/Cuadricoptero_vision/I2C_WRITE.pdf}
	\caption{Diagrama de flujo de la escritura I2C.}
	\label{fig:i2c_write}
\end{figure}

Está compuesto por una máquina de 13 estados en los que cada uno tiene una función fundamental para conseguir el resultado deseado. Hay que trabajar a muy bajo nivel para evitar errores en la transmisión y dotar al sistema de las herramientas necesarias para la detección de posibles anomalías.

En una comunicación I2C es importante que tanto maestro como esclavo compartan los buses scl y sda, los cuáles estarán en alta siempre excepto cuando alguno de los dos anteriores impogan su paso a bajo nivel de voltaje, tierra en este caso. I2C basa su funcionamiento en reconocer en todo momento estos niveles de voltaje por lo que hay que asegurarse de que siempre exista la condición de que si el bus esta libre, el nivel de voltaje es alto. Para ello, ambos buses suelen tener una conexión a una resistencia de pull-up que facilite esta características y evite en todo momento posibles glitches de reloj, mala referencia de tierra, ruido, etc. El esquemático de conexiones de la camára será por tanto el representado en la \ref{fig:OV7670_schematic}.

\begin{figure}[H]
	\center
	\includegraphics[scale=0.6, angle=0]{imagenes/Cuadricoptero_vision/OV7670_schematic}
	\caption{Esquemático para cámara OV7670.}
	\label{fig:OV7670_schematic}
\end{figure}

Uno de los problemas mas importantes en el desarrollo de este módulo recae el gobierno temporal de estos buses por parte del esclavo y el maestro. Para entenderlo se describe el ejemplo \ref{ejemplo:i2c}.

\begin{ejemplo}\label{ejemplo:i2c}
 Se requiere en primera instancia que el maestro imponga el bus SDA a alto nivel de voltaje.
 A continuación, el maestro debe quedarse a la espera de una contestación por parte del esclavo, el cuál es un dispositivo no controlado y externo a nuestro sistema. Cuando el esclavo intente escribir en el bus, se encontrará un nivel de voltaje impuesto por el maestro, y el cuál no se podrá cambiar.
\end{ejemplo}

Para corregir el problema expuesto en el ejemplo \ref{ejemplo:i2c} el dispositivo a la escucha deberá imponer un estado de alta impedancia eléctrica con respecto al bus. Se hace uso por tanto de un buffer triestado como el que se representa en la figura \ref{fig:buffer_triestado} y que permite ese comportamiento de manera controlada.
\begin{figure}[H]
	\center
	\includegraphics[scale=0.6, angle=0]{imagenes/Cuadricoptero_vision/triestado}
	\caption{Buffer triestado para bus I2C.}
	\label{fig:buffer_triestado}
\end{figure}

Un ejemplo de la escritura en I2C en el módulo OV7670 se representa en la figura \ref{fig:i2c_example}.

\begin{figure}[H]
	\center
	\includegraphics[scale=0.4, angle=0]{imagenes/Cuadricoptero_vision/i2c_example}
	\caption{Ejemplo de escritura I2C en OV7670.}
	\label{fig:i2c_example}
\end{figure}

\subsubsection{Almacenamiento de píxeles. }

Uno de los problemas mas importantes con los que hay que libiar cuando se trabaja con el módulo OV7670 y con la intención del reconocimiento de objetos en tiempo real y sin retraso, es la necesidad de una memoria FIFO que almacene los píxeles que van llegando, ya que para obtener una imagen completa de 640x480 es necesario almacenar en memoria 307200 píxeles. En este caso, y teniendo en cuenta que cada píxel esta formado por dos bytes, el tamaño total de un fotograma sería el expuesto en la ecuación \ref{eq:pixeles}.

\begin{equation}\label{eq:pixeles}
	(640*480)*(16) = 4915200  \ \ \textup{bits por fotograma} 
\end{equation}

El dispositivo que controle la cámara deberá poder almacenar esa cantidad de datos para luego poder analizarla. \newline

En caso de usar un microcontrolador, se suele incorporar al sistema una memoria FIFO con la capacidad de almacenar esa cantidad de datos. En este proyecto se usa para el análisis de imagen la tarjeta FPGA IceZum Alhambra y el modo de operar cambia considerablemente con el anterior.\newline

Después del análisis de diferentes alternativas, la más adecuada y con la que se obtiene un mayor rendimiento se basa en la no necesidad de almacenar una imagen completa, para entender este concepto, se explicará brevemente la parte relacionada con la posición y volumen de un objeto.

\subsubsection{Reconocimiento pelota roja}

El reconocimiento del volumen y posicionamiento del objeto se calculará píxel a píxel en lugar de una vez obtenida la imagen completa, así el algoritmo quedaría de la siguiente manera:

\begin{itemize}
	\item En primera instancia se define el filtro de color, el cuál permitirá reconocer el rango de color del píxel en este caso, de la pelota roja. Se definen por tanto un rango de color para cada componente roja, verde y azul.
	\item Los píxeles llegarán de manera secuencial, dos bytes por píxeles. El módulo OV7670 tiene como salidas los pines D7,D6,D5,D4,D3,D2,D1,D0 correspondientes a los bits de cada componente del píxel como se muestra en la figura \ref{fig:OV7670_schematic}.
	\item Un contador interno será el encargado de llevar la cuenta del número de píxeles totales que han pasado el filtro. Cuando se haya terminado el frame completo se puede obetener por tanto el volumen del objeto, y con ello, la distancia a este, como se muestra en la ecuación \ref{equation:filtro}.
	\begin{equation} \label{equation:filtro}
		Volumen = Num_{\textup{pixeles filtrados}}/Num_{\textup{píxeles totales}}
	\end{equation}
	\item Se tiene una cuenta de la posición dentro del frame donde se encuentran los píxeles que han pasado el filtro, la posicion en filas y en columnas y a partir de lo cuál se puede obtener una estimación de la posición del objeto dentro del aérea de visión como se expone en las ecuaciones \ref{equation:acumx} y \ref{equation:acumy}.
	
	\begin{equation}\label{equation:acumx}
		Acum_{X} = sum(\textup{columna de los pixeles que pasan el filtro})
	\end{equation}
	
	\begin{equation}\label{equation:acumy}
		Acum_{Y} = sum(\textup{fila de los pixeles que pasan el filtro})
 	\end{equation}
	
	
	\end{itemize}

	Para lograr el comportamiento anterior es necesario por tanto conocer en cada preciso instante cual es el valor de la fila y la columna del píxel en cuestión. 
	
	Se desarrolla dos módulos independientes, cuyas salidas proporcionan estas requeridas posiciones.
	
	\textbf{Modulo filas}
	
	\textbf{Modulo columnas}
	
	Debido a la importancia de estos módulos, se explica el desarolloo de uno de ellos mediante su diagrama de flujo expuesto en la figura tal
	
	\textbf{diagrama de flujo}
	
	Como es conocido, el módulo OV7670 proporciona una señal de reloj denominada PXCLK la cuál proporcionará la sincronía de este módulo. Por otra parte, es importante el conocimiento de las señales de sincronía con las que cuenta toda señal VGA y que se representa en la figura
	
	\textbf{señales de sincronia}
	
	Se cuenta con una señal de sincronía horizontal que avisará del cambio de fila en el frame y una señal de sincronía vertical para el cambio de frame.
	
	En primer lugar en el proceso de conocimiento de una fila es preciso detectar cuando empieza y cuando acaba. Se ha propuesto por tanto una maquina de estados en la que cada estado supone un cambio en el bus de la señal de sincronía horizontal. 

\section{Implementación del control}



\section{Experimentos}









